/*
 *  Copyright (C) 2015, 2016 Marek Marecki
 *
 *  This file is part of Viua VM.
 *
 *  Viua VM is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Viua VM is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Viua VM.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <cstdint>
#include <iostream>
#include <sstream>
#include <viua/support/string.h>
#include <viua/bytecode/opcodes.h>
#include <viua/bytecode/maps.h>
#include <viua/cg/tools.h>
#include <viua/program.h>
using namespace std;


viua::internals::types::byte* Program::bytecode() {
    /*  Returns pointer to a copy of the bytecode.
     *  Each call produces new copy.
     *
     *  Calling code is responsible for proper destruction of the allocated memory.
     */
    viua::internals::types::byte* tmp = new viua::internals::types::byte[bytes];
    for (decltype(bytes) i = 0; i < bytes; ++i) {
        tmp[i] = program[i];
    }
    return tmp;
}

Program& Program::fill(viua::internals::types::byte* code) {
    /** Fill generator with pre-generated bytecode.
     *
     *  Previous copy is deleted.
     *  Calling code must not delete passed bytecode.
     */
    delete[] program;
    program = code;
    addr_ptr = program;
    return (*this);
}


Program& Program::setdebug(bool d) {
    /** Sets debugging status.
     */
    debug = d;
    return (*this);
}

Program& Program::setscream(bool d) {
    /** Sets screaming status.
     */
    scream = d;
    return (*this);
}


uint64_t Program::size() {
    /*  Returns program size in bytes.
     */
    return bytes;
}

using Token = viua::cg::lex::Token;
Program& Program::calculateJumps(vector<tuple<uint64_t, uint64_t> > jump_positions, vector<Token>& tokens) {
    /** Calculate jump targets in given bytecode.
     */
    uint64_t* ptr = nullptr;

    uint64_t position, offset;
    uint64_t adjustment;
    for (auto jmp : jump_positions) {
        tie(position, offset) = jmp;

        // usually beware of the reinterpret_cast<>'s but here we *know* what we're doing
        // we *know* that this location points to uint64_t even if it is stored inside the viua::internals::types::byte array
        ptr = reinterpret_cast<uint64_t*>(program+position);
        if (debug) {
            cout << "[bcgen:jump] calculating jump at " << position << " (target: " << *ptr << ") with offset " << offset << endl;
        }
        adjustment = viua::cg::tools::calculate_bytecode_size_of_first_n_instructions2(tokens, *ptr);
        (*ptr) = (offset + adjustment);
        if (debug) {
            cout << "[bcgen:jump] calculated jump at " << position << " (total: " << adjustment << ") with offset " << offset << " = ";
            cout << *ptr << endl;
        }
    }

    return (*this);
}

vector<uint64_t> Program::jumps() {
    /** Returns vector if bytecode points which contain jumps.
     */
    vector<uint64_t> jmps;
    for (viua::internals::types::byte* jmp : branches) { jmps.push_back( static_cast<uint64_t>(jmp-program) ); }
    return jmps;
}

Program::Program(uint64_t bts): bytes(bts), debug(false), scream(false) {
    program = new viua::internals::types::byte[bytes];
    /* Filling bytecode with zeroes (which are interpreted by kernel as NOP instructions) is a safe way
     * to prevent many hiccups.
     */
    for (decltype(bytes) i = 0; i < bytes; ++i) { program[i] = viua::internals::types::byte(0); }
    addr_ptr = program;
}
Program::Program(const Program& that): program(nullptr), bytes(that.bytes), addr_ptr(nullptr), branches({}) {
    program = new viua::internals::types::byte[bytes];
    for (decltype(bytes) i = 0; i < bytes; ++i) {
        program[i] = that.program[i];
    }
    addr_ptr = program+(that.addr_ptr - that.program);
    for (unsigned i = 0; i < that.branches.size(); ++i) {
        branches.push_back(program+(that.branches[i]-that.program));
    }
}
Program::~Program() {
    delete[] program;
}
Program& Program::operator=(const Program& that) {
    if (this != &that) {
        delete[] program;
        bytes = that.bytes;
        program = new viua::internals::types::byte[bytes];
        for (decltype(bytes) i = 0; i < bytes; ++i) {
            program[i] = that.program[i];
        }
        addr_ptr = program+(that.addr_ptr - that.program);
        while (branches.size()) { branches.pop_back(); }
        for (unsigned i = 0; i < that.branches.size(); ++i) {
            branches.push_back(program+(that.branches[i]-that.program));
        }
    }
    return (*this);
}
