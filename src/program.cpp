/*
 *  Copyright (C) 2015, 2016 Marek Marecki
 *
 *  This file is part of Viua VM.
 *
 *  Viua VM is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Viua VM is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Viua VM.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <cstdint>
#include <iostream>
#include <memory>
#include <sstream>
#include <viua/bytecode/maps.h>
#include <viua/bytecode/opcodes.h>
#include <viua/cg/tools.h>
#include <viua/program.h>
#include <viua/support/string.h>
#include <viua/util/memory.h>
using namespace std;

using viua::util::memory::aligned_write;
using viua::util::memory::load_aligned;


auto Program::bytecode() const -> std::unique_ptr<viua::internals::types::byte[]> {
    /*  Returns pointer to a copy of the bytecode.
     *  Each call produces new copy.
     *
     *  Calling code is responsible for proper destruction of the allocated
     * memory.
     */
    auto tmp = make_unique<viua::internals::types::byte[]>(bytes);
    for (decltype(bytes) i = 0; i < bytes; ++i) {
        tmp[i] = program[i];
    }
    return tmp;
}

Program& Program::fill(std::unique_ptr<viua::internals::types::byte[]> code) {
    /** Fill generator with pre-generated bytecode.
     *
     *  Previous copy is deleted.
     *  Calling code must not delete passed bytecode.
     */
    program  = std::move(code);
    addr_ptr = program.get();
    return (*this);
}


Program& Program::setdebug(bool d) {
    /** Sets debugging status.
     */
    debug = d;
    return (*this);
}

Program& Program::setscream(bool d) {
    /** Sets screaming status.
     */
    scream = d;
    return (*this);
}


uint64_t Program::size() {
    /*  Returns program size in bytes.
     */
    return bytes;
}

using Token = viua::cg::lex::Token;
Program& Program::calculate_jumps(
    std::vector<tuple<uint64_t, uint64_t>> jump_positions,
    std::vector<Token>& tokens) {
    /** Calculate jump targets in given bytecode.
     */
    uint64_t* ptr = nullptr;

    uint64_t position, offset;
    uint64_t adjustment;
    for (auto jmp : jump_positions) {
        tie(position, offset) = jmp;

        // usually beware of the reinterpret_cast<>'s but here we *know* what
        // we're doing we *know* that this location points to uint64_t even if
        // it is stored inside the viua::internals::types::byte array
        ptr = reinterpret_cast<uint64_t*>(program.get() + position);
        if (debug) {
            cout << "[bcgen:jump] calculating jump at " << position
                 << " (target: " << *ptr << ") with offset " << offset << endl;
        }
        adjustment =
            viua::cg::tools::calculate_bytecode_size_of_first_n_instructions2(
                tokens, load_aligned<uint64_t>(ptr));
        aligned_write(ptr) = (offset + adjustment);
        if (debug) {
            cout << "[bcgen:jump] calculated jump at " << position
                 << " (total: " << adjustment << ") with offset " << offset
                 << " = ";
            cout << *ptr << endl;
        }
    }

    return (*this);
}

std::vector<uint64_t> Program::jumps() {
    auto jmps = std::vector<uint64_t>{};
    for (auto const jmp : branches) {
        jmps.push_back(static_cast<uint64_t>(jmp - program.get()));
    }
    return jmps;
}

Program::Program(uint64_t bts) : bytes(bts), debug(false), scream(false) {
    program = make_unique<viua::internals::types::byte[]>(bytes);
    /* Filling bytecode with zeroes (which are interpreted by kernel as NOP
     * instructions) is a safe way to prevent many hiccups.
     */
    for (decltype(bytes) i = 0; i < bytes; ++i) {
        program[i] = viua::internals::types::byte(0);
    }
    addr_ptr = program.get();
}
Program::Program(Program const& that)
        : program(nullptr), bytes(that.bytes), addr_ptr(nullptr), branches({}) {
    program = make_unique<viua::internals::types::byte[]>(bytes);
    for (decltype(bytes) i = 0; i < bytes; ++i) {
        program[i] = that.program[i];
    }
    addr_ptr = program.get() + (that.addr_ptr - that.program.get());
    for (unsigned i = 0; i < that.branches.size(); ++i) {
        branches.push_back(program.get()
                           + (that.branches[i] - that.program.get()));
    }
}
Program& Program::operator=(Program const& that) {
    if (this != &that) {
        bytes   = that.bytes;
        program = make_unique<viua::internals::types::byte[]>(bytes);
        for (decltype(bytes) i = 0; i < bytes; ++i) {
            program[i] = that.program[i];
        }
        addr_ptr = program.get() + (that.addr_ptr - that.program.get());
        while (branches.size()) {
            branches.pop_back();
        }
        for (unsigned i = 0; i < that.branches.size(); ++i) {
            branches.push_back(program.get()
                               + (that.branches[i] - that.program.get()));
        }
    }
    return (*this);
}
