bits_literal: 0b00000000
            | 0xdeadbeef

bool_literal: true
            | false

--------------------------------------------------------------------------------

> means output register with no new value created
< means input register with value removed
+ means output register with new value created
~ means mutated register

add:
sub:
mul:
div:
lt:
lte:
gt:
gte:
eq:
    +fetch_register
    fetch_object_of<Number>
    fetch_object_of<Number>

atom:
    +fetch_register
    fetch_primitive_string

atomeq:
    +fetch_register
    fetch_object_of<Atom>
    fetch_object_of<Atom>

bits_of_integer:
    +fetch_register
    fetch_object_of<Integer>

integer_of_bits:
    +fetch_register
    fetch_object_of<Bits>

bits:
    +fetch_register
    fetch_object_of<Integer> | bits_literal

bitand:
bitor:
bitxor:
    +fetch_register
    fetch_object_of<Bits>
    fetch_object_of<Bits>

bitnot:
    +fetch_register
    fetch_object_of<Bits>

bitat:
    +fetch_register
    fetch_object_of<Bits>
    fetch_object_of<Integer>

bitset:
    ~fetch_object_of<Bits>
    fetch_object_of<Integer>
    bool_literal | fetch_object_of<Boolean>

shl:
shr:
ashl:
ashr:
    +fetch_register | void
    fetch_object_of<Bits>
    fetch_object_of<Integer>

rol:
ror:
    ~fetch_object_of<Bits>
    fetch_object_of<Integer>

wrapincrement:
wrapdecrement:
checkedsincrement:
checkedsdecrement:
saturatingsincrement:
saturatingsdecrement:
    ~fetch_object_of<Bits>

wrapadd:
wrapsub:
wrapmul:
wrapdiv:
checkedsadd:
checkedssub:
checkedsmul:
checkedsdiv:
saturatingsadd:
saturatingssub:
saturatingsmul:
saturatingsdiv:
    +fetch_register
    fetch_object_of<Bits>
    fetch_object_of<Bits>

not:
    +fetch_register
    fetch_object

and:
or:
    +fetch_register
    fetch_object
    fetch_object

frame:
    fetch_register_index # used to indicate a number of argument registers to
                         # allocate, not as a real address
    fetch_register_index # unused

param:
    +fetch_register_index
    fetch_register

pamv:
    +fetch_register_index
    <fetch_register

arg:
    >fetch_register | void
    <fetch_register_index

allocate_registers:
    fetch_register       # used to indicate how many registers should be
                         # allocated, not as a real address

call:
    +fetch_register | void
    fetch_register | string_literal

tailcall:
defer:
    fetch_register | string_literal

return:
    none

itof:
    +fetch_register
    fetch_object_of<Integer>

ftoi:
    +fetch_register
    fetch_object_of<Float>

stoi:
    +fetch_register
    fetch_object_of<String>

stof:
    +fetch_register
    fetch_object_of<String>

capture:
capturecopy:
capturemove:
    ~fetch_object_of<Closure>
    fetch_register_index
    fetch_register

closure:
function:
    +fetch_register
    string_literal

process:
    +fetch_register | void
    fetch_object_of<Function> | string_literal

join:
    +fetch_register | void
    fetch_object_of<Process>
    fetch_timeout

send:
    fetch_object_of<Process>
    <fetch_register

receive:
    +fetch_register | void
    fetch_timeout

watchdog:
    string_literal

self:
    +fetch_register

pideq:
    +fetch_register
    fetch_object_of<Process>
    fetch_object_of<Process>

float:
    +fetch_register
    float_literal

izero:
    +fetch_register

integer:
    +fetch_register
    integer_literal

iinc:
idec:
    ~fetch_object_of<Integer>

io_read:
io_write:
    +fetch_register
    fetch_register
    fetch_register

io_close:
    +fetch_register
    fetch_object_of<IO_port>

io_wait:
    +fetch_register | void
    fetch_object_of<IO_request>
    fetch_timeout

io_cancel:
    ~fetch_object_of<IO_request>

import:
    string_literal  # a fetch_object_of<String> overload would be needed

move:
    >fetch_register
    <fetch_register

copy:
    +fetch_register
    fetch_register

ptr:
    +fetch_register
    fetch_register

ptrlive:
    +fetch_register
    fetch_object_of<Pointer>

swap:
    <>fetch_register
    <>fetch_register

delete:
    <fetch_register

isnull:
    +fetch_register
    fetch_register

string:
    +fetch_register
    string_literal

struct:
    +fetch_register

structinsert:
    ~fetch_object_of<Struct>
    fetch_object_of<Atom>
    <fetch_register | fetch_object

structremove:
    >fetch_register | void
    ~fetch_object_of<Struct>
    fetch_object_of<Atom>

structat:
    +fetch_register | void
    fetch_object_of<Struct>
    fetch_object_of<Atom>

structkeys:
    +fetch_register
    fetch_object_of<Struct>

try:
    none

catch:
    string_literal
    string_literal

draw:
    >fetch_register | void

enter:
    string_literal

throw:
    <fetch_register

leave:
    none

text:
    +fetch_register
    string_literal | fetch_object

texteq:
textcommonprefix:
textcommonsuffix:
textconcat:
    +fetch_register
    fetch_object_of<Text>
    fetch_object_of<Text>

textat:
    +fetch_register
    fetch_object_of<Text>
    fetch_object_of<Integer>

textsub:
    +fetch_register
    fetch_object_of<Integer>
    fetch_object_of<Integer>

textlength:
    +fetch_register
    fetch_object_of<Text>

vector:
    +fetch_register
    fetch_register  # begin pack
    fetch_register  # pack size

vinsert:
    ~fetch_object_of<Vector>
    fetch_register
    fetch_object_of<Integer> | void

vpush:
    ~fetch_object_of<Vector>
    fetch_register

vpop:
    >fetch_register | void
    ~fetch_object_of<Vector>
    fetch_object_of<Integer> | void

vat:
    +fetch_register
    fetch_object_of<Vector>
    fetch_object_of<Integer>

vlen:
    +fetch_register
    fetch_object_of<Vector>

--------------------------------------------------------------------------------

fetch_register: fetch a value allowing r/w access to a register
fetch_object_of<>: fetch a value of a certain type from a register
fetch_object: fetch a value of any type from register
fetch_register_index: fetch a register index (but no access type or set)

All these are encoded in the bytecode the same way (as a value access form). The
only difference is how they are interpreted at runtime. A constraint is that the
`fetch_register` can not use pointer-dereference access type.

--------------------------------------------------------------------------------

string_literal

A string literal may represent a byte string, an atom, a text string (a sequence
of Unicode codepoints encoded in UTF-8), or a symbol name (function, module,
block, exception). They are all encoded the same way: as a null-terminated byte
string, and the only difference is how they are interpreted at runtime.

Note: string literals should be represented as length-prefixed binary data, as a
byte string *may* contain zero character. Byte strings are for arbitrary
strings, and text should be used to hold textual data.
